# Тесты всех заданий:

# Задание 1. Кот

## 1. Кот мяукает.
Создайте сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров.
• Может помяукать N раз, что приводит к выводу на экран следующего текста: “Имя: мяу-
мяу-
…
-мяу!”, где количество “
мяу”равно N.
Создайте кота по имени “Барсик”, и затем пусть он помяукает сначала один раз, а затем три раза.
## Решение:
1. Создать класс Cat с полем Name (имя кота)
2. Реализовать метод Meow() для одиночного мяуканья
3. Реализовать метод Meow(int n) для мяуканья N раз
4. Обеспечить валидацию входных данных
## Тест 1:
Введите имя кота: Барсик

Кот: Барсик

Выберите действие:

1 — Мяукнуть ОДИН раз

2 — Мяукнуть N раз

0 — Вернуться в меню подзаданий

1

Барсик: мяу!

Кот: Барсик

Выберите действие:

1 — Мяукнуть ОДИН раз

2 — Мяукнуть N раз

0 — Вернуться в меню подзаданий

2

Введите N:

Введите количество: 3

Барсик: мяу-мяу-мяу!

## Тест 2:
Введите имя кота: Рыжик

Кот: Рыжик

Выберите действие:

1 — Мяукнуть ОДИН раз

2 — Мяукнуть N раз

0 — Вернуться в меню подзаданий

1

Рыжик: мяу!

Кот: Рыжик

Выберите действие:

1 — Мяукнуть ОДИН раз

2 — Мяукнуть N раз

0 — Вернуться в меню подзаданий

2

Введите N:

Введите количество: -1

Ошибка: количество ≥ 1

Введите количество: 10

Рыжик: мяу-мяу-мяу-мяу-мяу-мяу-мяу-мяу-мяу-мяу!

## 2. Интерфейс Мяуканье.
Разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у
каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
public void meow();
Дополните решение предыдущей задачи так, чтобы иметь возможность передать Кота в написанный
вами метод и протестируйте работоспособность решения передав в него нескольких котов, а также
создайте любой другой произвольный класс и передайте в написанный метод его объекты.
## Решение:
1. Создать интерфейс IMeowable с методом Meow()
2. Класс Cat реализует IMeowable
3. Создать класс RobotCat (робот-кот), реализующий IMeowable
4. Реализовать статический метод MeowAll() для вызова Meow() у всех объектов
## Тест 1:
Сколько обычных котов создать?

Введите количество: 2

Введите имя кота #1:

Введите имя: Барсик

Введите имя кота #2:

Введите имя: Боря

Сколько робокотов создать?

Введите количество: 2

Введите модель робокота #1:

Введите модель: РобоБарсик

Введите модель робокота #2:

Введите модель: РобоБоря

Вызов MeowAll() для всех мяукающих объектов:

Барсик: мяу!

Боря: мяу!

РобоБарсик: электронное мяу!

РобоБоря: электронное мяу!

## Тест 2:
Сколько обычных котов создать?

Введите количество: -1

Ошибка: количество ≥ 1

Введите количество: 1

Введите имя кота #1:

Введите имя: Яша

Сколько робокотов создать?

Введите количество: 1

Введите модель робокота #1:

Введите модель: Бот Шарик

Вызов MeowAll() для всех мяукающих объектов:

Яша: мяу!

Бот Шарик: электронное мяу!

## 3. Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из предыдущего
задания. Необходимо таким образом передать кота в указанный метод, что бы после окончания его
работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед
вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы
выводим количество мяуканий на экран. Кота изменять нельзя.
## Решение:
1. Добавить свойство MeowCount в класс Cat для подсчета мяуканий
2. Использовать метод MeowAll() с одним котом 
3. Сравнить количество мяуканий до и после вызова
## Тест 1:
ВВведите имя кота: Барсик

Сколько раз вызвать общий метод MeowAll() для этого кота?

Введите количество: 9

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Барсик: мяу!

Кот Барсик мяукал 9 раз во время работы метода.

## Тест 2:
Введите имя кота: Бурбон

Сколько раз вызвать общий метод MeowAll() для этого кота?

Введите количество: -1

Ошибка: количество ≥ 1

Введите количество: 2

Бурбон: мяу!

Бурбон: мяу!

Кот Бурбон мяукал 2 раз во время работы метода.

# Задание 2. Дроби

## 1. Дроби.
Создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Может выполнять операции сложения, вычитания, умножения и деления с другой
Дробью или целым числом. Результатом операции должна быть новая Дробь (таким
образом, обе исходные дроби не изменяются) (Обязательно использовать перегрузки!)
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не
может быть отрицательным.
Затем необходимо выполнить следующие задачи:
1. Создать несколько экземпляров дробей.
2. Написать по одному примеру использования каждого метода.
3. Вывести на экран примеры и результаты их выполнения в формате «1/3 * 2/3 = 2/9»
4. Посчитать f1.sum(f2).div(f3).minus(5)
## Решение:
1. Создать класс Fraction с полями Numerator и Denominator
2. Реализовать основные арифметические операции (+, -, *, /)
3. Реализовать операции с целыми числами
4. Обеспечить проверку знаменателя на ноль
## Тест 1:
Введите первую дробь:

Введите числитель: 1

Введите знаменатель: 2

Введите вторую дробь:

Введите числитель: 2

Введите знаменатель: 3

Введите третью дробь:

Введите числитель: 3

Введите знаменатель: 4
 
Введите Целое число: 2

Примеры операций с дробями:

1/2 + 2/3 = 7/6

2/3 - 3/4 = -1/12

2/3 * 3/4 = 6/12

3/4 / 2/3 = 9/8

Примеры операций с целыми числами:

1/2 + 2 = 5/2

2/3 - 2 = -4/3

2/3 * 2 = 4/3

3/4 / 2 = 3/8

2 + 1/2 = 5/2

2 - 2/3 = 4/3

2 * 2/3 = 4/3

2 / 3/4 = 8/3

Цепочка:

f1.sum(f2).div(f3).minus(5) = -62/18


## Тест 2:
Введите первую дробь:

Введите числитель: -1

Введите знаменатель (n>0): -1

Ошибка: знаменатель не может быть меньше либо равен нулю

Введите знаменатель (n>0): 2

Введите вторую дробь:

Введите числитель: -1

Введите знаменатель (n>0): 2

Введите третью дробь:

Введите числитель: -1

Введите знаменатель (n>0): 2

Введите целое число для операций:

Введите целое число: 5

Примеры операций с дробями:

-1/2 + -1/2 = -4/4

-1/2 - -1/2 = 0/4

-1/2 * -1/2 = 1/4

-1/2 / -1/2 = Ошибка: Числитель делителя не может быть меньше либо равен нулю

Примеры операций с целыми числами:

-1/2 + 5 = 9/2

-1/2 - 5 = -11/2

-1/2 * 5 = -5/2

-1/2 / 5 = -1/10

5 + -1/2 = 9/2

5 - -1/2 = 11/2

5 * -1/2 = -5/2

5 / -1/2 = Ошибка: Числитель делителя не может быть меньше либо равен нулю

Сравнение дробей:

-1/2 == -1/2: True

-1/2 == -1/2 (копия): True

Цепочка:

f1.sum(f2).div(f3).minus(5) = Ошибка: Числитель делителя не может быть меньше либо равен нулю

## 2. Сравнение дробей.
Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
## Решение:
1. Переопределить метод Equals() для сравнения дробей
2. Сравнивать дроби по значениям числителя и знаменателя

## Тест 1:
Сравнение дробей:

1/2 == 3/4: False

1/2 == 1/2 (копия): True
## Тест 2:
Сравнение дробей:

1/2 == 1/2: True

1/2 == 1/2 (копия): True
## Тест 3:
Сравнение дробей:

-1/2 == -1/2: True

-1/2 == -1/2 (копия): True
## 3. Клонирование дроби. Интерфейс ICloneable.
Переопределите метод клонирования, таким образом, чтобы при его вызове возвращался новый
объект Дроби, значения полей которого будут копиями оригинальной Дроби.
## Решение:
1. Реализовать интерфейс ICloneable
2. Метод Clone() должен создавать новую дробь с такими же значениями
## Тест 1:
Клонирование:

Оригинал: 1/2, Клон: 1/2

Оригинал == Клон: True
## Тест 2:
Клонирование:

Оригинал: -1/2, Клон: -1/2

Оригинал == Клон: True
## Тест 3:
Клонирование:

Оригинал: 3/4, Клон: 3/4

Оригинал == Клон: True

## 4. В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка
числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного
значения.
## Решение:
1. Создать класс CachedFraction, наследующий Fraction
2. Реализовать интерфейс IFractionAdvanced
3. Добавить кэширование для double-значения
4. Сброс кэша при изменении числителя или знаменателя
## Тест 1:
Кэширование:

Первый вызов ToDouble(): 0,5

Второй вызов ToDouble(): 0,5

Изменяем числитель(умножаем на 2)

Третий вызов ToDouble() (после изменения): 1

Четвертый вызов ToDouble(): 1
## Тест 2:
Кэширование:

Первый вызов ToDouble(): -0,5

Второй вызов ToDouble(): -0,5

Изменяем числитель(умножаем на 2)

Третий вызов ToDouble() (после изменения): -1

Четвертый вызов ToDouble(): -1
## Тест 3:
Кэширование:

Первый вызов ToDouble(): 1

Второй вызов ToDouble(): 1

Изменяем числитель(умножаем на 2)

Третий вызов ToDouble() (после изменения): 2

Четвертый вызов ToDouble(): 2
